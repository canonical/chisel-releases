package: libpam-runtime

essential:
  - libpam-runtime_copyright

slices:
  # perl scripts that rely on debconf to properly work and discover
  # plugins/rules in /usr/share/pam-configs/*
  # /usr/sbin/pam-auth-update:
  # /usr/sbin/pam_getenv:
  # The libpam-runtime package caries nothing that can actually be directly
  # used by other packages. The files that are used, are generated by "usr/sbin/pam-auth-update"
  # based on input from /usr/share/pam-configs/* and outputs five different files into
  # /etc/pam.d/common-{account,auth,password,session,session-non-interactive}. The contents
  # of those are directly derived from the contents of the pam-configs.
  # Other packages can carry these pam-configs too, and usually invoke pam-auth-update
  # to regenerate these five files mentioned.
  # pam-config and pam-defaults slices are only used for generation, and are useless
  # for anything else.

  # Emulate in part what pam-auth-update does. There is a short coming right now, we
  # cannot include other files from other slices that install into
  #   /usr/share/pam-configs/*
  # since this mutation script wont be able to access them as of writing.
  config:
    essential:
      - libpam-runtime_var
    contents:
      /etc/pam.conf:
      /etc/pam.d/common-account: {text: '', mutable: true}
      /etc/pam.d/common-auth: {text: '', mutable: true}
      /etc/pam.d/common-password: {text: '', mutable: true}
      /etc/pam.d/common-session: {text: '', mutable: true}
      /etc/pam.d/common-session-noninteractive: {text: '', mutable: true}
      /etc/pam.d/other:
      /usr/share/pam-configs/unix: { until: mutate }
      /usr/share/pam/common-account: { until: mutate }
      /usr/share/pam/common-auth: { until: mutate }
      /usr/share/pam/common-password: { until: mutate }
      /usr/share/pam/common-session: { until: mutate }
      /usr/share/pam/common-session-noninteractive: { until: mutate }
    mutate: |
      def parse_type(t):
        strippedValue = t[1].strip()
        if t[0] == "Auth-Type":
            return ["auth", strippedValue]
        elif t[0] == "Account-Type":
          return ["account", strippedValue]
        elif t[0] == "Session-Type":
          return ["session-noninteractive", strippedValue]
        elif t[0] == "Password-Type":
          return ["password", strippedValue]
        return []

      confs_dir = "/usr/share/pam-configs/"
      confs = content.list(confs_dir)
      confdata = {}
      for x in confs:
        conf = content.read(confs_dir + x)
        lines = conf.splitlines()

        m = ""
        p = ""
        t = ""
        for i in range(len(lines)):
          vals = lines[i].split(":")
          if vals[0] == "Priority":
            p = vals[1].strip()
          elif vals[0] in ["Auth-Type", "Account-Type", "Session-Type", "Password-Type"]:
            m, t = parse_type(vals)
          elif vals[0] == "Session-Interactive-Only":
            if vals[1].strip() == "yes":
              m = "session"
          elif vals[0] in ["Auth", "Account", "Session", "Password"]:
            d = []
            for j in range(i + 1, len(lines)):
              if ":" in lines[j]:
                break
              d.append(lines[j])
            confdata[m] = {t: {p: d}}

      def reconfigure_data_line(section, line, i):
        res = ""
        upd = line.replace("success=end", "success=" + str(i))
        if section == "session-noninteractive":
          res += "session" + upd + "\n"
        else:
          res += section + upd + "\n"
        return res

      def build_block(data, section, block, existing):
        si = 1
        res = existing
        if section in data:
          types = data[section]
          if block in types:
            # get the keys (which are the priorities) and
            # then reverse sort them to get the highest priority
            # first
            itemsByPriority = types[block]
            keys = itemsByPriority.keys()
            keys = sorted(keys, reverse=True)
            for p in keys:
              for d in itemsByPriority[p]:
                res = reconfigure_data_line(section, d, si) + "\n"
                si += 1

        # no primary block, so output a stock pam_permit line
        # to keep the stack intact
        if res == "" and block == "Primary":
          return reconfigure_data_line(section, "\t[default=1]\t\t\tpam_permit.so\n", 1);
        return res

      fnames = ["account", "auth", "password", "session", "session-noninteractive"]
      idnames = ["$account", "$auth", "$password", "$session", "$session_nonint"]

      for i in range(len(fnames)):
        fn = fnames[i]
        template = content.read("/usr/share/pam/common-" + fn)
        pb = build_block(confdata, fn, "Primary", "")
        ab = build_block(confdata, fn, "Additional", "")

        # session also includes settings from the session-noninteractive,
        # but not the other way around
        if fn == "session":
          pb = build_block(confdata, "session-noninteractive", "Primary", pb)
          ab = build_block(confdata, "session-noninteractive", "Additional", ab)

        template = template.replace(idnames[i] + "_primary", pb)
        template = template.replace(idnames[i] + "_additional", ab)
        content.write("/etc/pam.d/common-" + fn, template)

  # the following two slices are kept for backwards-compatibility
  # however the pam-defaults have been modified to deliver correct
  # files instead of templates
  pam-config:
    contents:
      /usr/share/pam-configs/unix:

  pam-defaults:
    essential:
      - libpam-runtime_config

  # folders expected by libpam to exist
  var:
    contents:
      /var/lib/pam/:

  copyright:
    contents:
      /usr/share/doc/libpam-runtime/copyright:
