#!/bin/bash
#
# coverage-report - Generate a coverage report for changed slices
#
# Usage:
#   coverage-report <slices-in-changed-files.txt> <manifests-dir>
#
# Arguments:
#   slices-in-changed-files.txt   Text file with list of changed slices (one per line)
#   manifests-dir                 Directory containing package manifests
#
# Exit codes:
#   0   Success
#   1   General error
#
# Examples:
#   coverage-report slices.txt /path/to/manifests > report.json
#
# spellchecker: ignore zstdcat argjson

set -euo pipefail

# log - Log a message if DEBUG is enabled
#
# Arguments:
#   $1  Message to log
#
function log {
    if [ "${DEBUG:-0}" -eq 1 ]; then
        echo "[$(date --iso-8601=seconds)] $*" >&2
    fi
}

# intersection - Compute intersection of two space-separated lists
#
# Arguments:
#   $1  First space-separated list
#   $2  Second space-separated list
#
function intersection {
    comm -12 <(echo "$1" | tr ' ' '\n' | sort -u) <(echo "$2" | tr ' ' '\n' | sort -u)
}

# difference - Compute difference of two space-separated lists
#
# Arguments:
#   $1  First space-separated list
#   $2  Second space-separated list
#
function difference {
    comm -23 <(echo "$1" | tr ' ' '\n' | sort -u) <(echo "$2" | tr ' ' '\n' | sort -u)
}

# count - Count unique items in a space-separated list
#
# Arguments:
#   $1  Space-separated list
#
function count {
    local normalized=$(echo "$1" | tr -s '[:space:]' ' ' | xargs)
    if [ -z "$normalized" ]; then
        echo 0
    else
        echo "$normalized" | tr ' ' '\n' | sort -u | wc -l
    fi
}

# get_installed_slices - Get installed slices for a package from manifests
#
# Arguments:
#   $1  Manifests directory
#   $2  Package name
#
function get_installed_slices {
    local manifests_dir="$1"
    local pkg="$2"
    local installed_slices=""
    if [ -d "$manifests_dir/$pkg" ]; then
        for manifest in "$manifests_dir/$pkg/"*.wall; do
            if [ -f "$manifest" ]; then
                local slices_in_file="$(zstdcat "$manifest" | jq -r '. | select(.kind=="slice") | .name')"
                installed_slices="$installed_slices $(echo "$slices_in_file" | grep "^${pkg}_" )"
            fi
        done
        installed_slices="$(echo "$installed_slices" | tr ' ' '\n' | sort -u)"
    fi
    # remove leading empty newline and return
    echo "$installed_slices" | sed '/^$/d'
}

# Main function
#
function main {
    if [ "$#" -ne 2 ]; then
        echo "Usage: $0 <slices-in-changed-files.txt> <manifests-dir>" >&2
        exit 1
    fi
    local slices_in_changed_files="$1"
    local manifests_dir="$2"

    local packages="$(awk -F_ '{print $1}' "$slices_in_changed_files" | sort -u)"
    log "Packages to check: ${packages//[$'\n']/ }"

    local tests_json="{}"
    local total_changed=0
    local total_present=0

    # For each package, get all the installed slices from the subdirectory in the manifests_dir
    for pkg in $packages; do
        local changed="$(grep "^${pkg}_" "$slices_in_changed_files")"
        log "Changed slices for package $pkg: ${changed//[$'\n']/ }"
        
        local installed=$(get_installed_slices "$manifests_dir" "$pkg")

        local extra=$(difference "$installed" "$changed")
        if [ -n "$extra" ]; then
            log "Info: package $pkg has installed slices which are not in changed files: ${extra//[$'\n']/ }"
            # remove extra slices from installed, so they don't affect coverage calculation
            installed=$(difference "$installed" "$extra")
        fi
        log "Installed slices for package $pkg: ${installed//[$'\n']/ }"

        local n_changed=$(count "$changed")
        local present=$(intersection "$changed" "$installed")
        local n_present=$(count "$present")
        local coverage="0.00"
        if [ "$n_changed" -gt 0 ]; then
            coverage=$(awk "BEGIN {printf \"%.2f\", ($n_present / $n_changed) * 100}")
        fi
        total_changed=$((total_changed + n_changed))
        total_present=$((total_present + n_present))

        local missing=$(difference "$changed" "$installed")
        log "Package $pkg: coverage $coverage%, missing slices: ${missing//[$'\n']/ }"

        local missing_json="[]"
        if [ -n "$missing" ]; then
            missing_json=$(echo "$missing" | jq -R . | jq -s .)
        fi

        tests_json=$(jq --arg pkg "$pkg" \
            --argjson coverage "$coverage" \
            --argjson missing "$missing_json" \
            '. + {($pkg): {coverage: $coverage, missing: $missing}}' \
            <<<"$tests_json")
    done

    local total_coverage="0.00"
    if [ "$total_changed" -gt 0 ]; then
        total_coverage=$(awk "BEGIN {printf \"%.2f\", ($total_present / $total_changed) * 100}")
    fi
    log "Total coverage: $total_coverage% ($total_present/$total_changed)"

    # Output final JSON
    jq --monochrome-output -n \
        --argjson tests "$tests_json" \
        --argjson total_coverage "$total_coverage" \
        '{total_coverage: $total_coverage, tests: $tests}'
}

main "$@"